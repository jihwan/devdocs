---
layout: post
title: "ddd-start ch03 애그리거트"
description: "ddd-start ch03 애그리거트"
category: DDD
tags: [DDD]
---
{% include JB/setup %}

# Aggregate

## 애그리거트

`상위 수준에서 모델 간의 관계를 이해`

주요 도메인 개념 간의 관계를 파악하기 어렵다는 것은 곧 코드를 변경하고 확장하는 것이 어려워진다는 것을 의미. 상위 수준에서 모델이 어떻게 엮여 있는지 알아야 전체 모델을 망가뜨리지 않으면서 추가 요구사항을 모델에 반영할 수 있다. 이에 반해 세부적인 모델만 이해한 상태로는 코드를 수정하기가 두렵기 때문에 코드 변경을 최대한 회피하는 쪽으로 요구사항을 협의하게 된다.

안전장치 : 리팩토링, TDD

복잡한 도메인을 이해하고 관리하기 쉬운 단위로 만들려면 상위 수준에서 모델을 조망할 수 있는 방법이 필요한데 그것이 바로 `애그리거트` 이다.

`일관성을 관리하는 기준`

애그리거트는 관련된 모델을 하나로 모은것이기 때문에 한 애그리거트에 속한 객체는 유사하거나 **동일한 라이프사이클**을 갖는다. `도메인 규칙에 따라 애그리거트에 속한 구성요소는 대부분 함께 생성하고 함께 제거한다.`

`애그리거트는 경계를 갖는다.` 각 애그리거트는 독립 객체 군이며, 자기 자신을 관리할 뿐 다른 애그리거트를 관리하지 않는다. `관리하지 않으려면 어떻게 해야 할까? 참조를 안하면 된다.`

**경계를 설정할 때 기본이 되는 것은 `도메인 규칙`과 `요구사항`.
도메인 규칙에 따라 함께 생성되는 구성요소는 한 애그리거트에 속할 가능성이 높다,
요구사항에 따라 함께 변경되는 빈도가 높은 객체는 한 애그리거트에 속할 가능성이 높다.
누가 함께 생성하고, 함께 변경하는가? 가능성이 높은 것이지 항상 그런것은 아니다. 변경 주체가 다르고, 같은 라이프사이클이 아니면 서로 다른 애그리거트이다.**

## 애그리거트 루트

일관된 상태를 관리하는 주체. 애그리거트에서 어떤 변경에 따라 일관적으로 함께 변경되어야 하는 규칙들이 있는가? 도메인 규칙을 지키려면 애그리거트에 속한 모든 객체가 정상 상태를 가져야 한다. 애그리거트에 속한 모든 객체가 일관된 상태를 유지하려면 애그리거트 전체를 관리 할 주체가 필요한데 이 책임을 지는 것이 바로 애그리거트의 루트 엔티티 이다.

### 도메인 규칙과 일관성 (도메인 규칙 일관성을 제공하기위해서는 애그리거트 루트에서 도메인 기능을 구현한다.)

애그리거트 루트의 핵심 역할은 애그리거트의 일관성이 깨지지 않도록 하는 것이고, 이를 위해 애그리거트 루트는 애그리거트가 제공해야할 도메인 기능을 구현한다.

애그리거트 루트가 아닌 다른 객체가 애그리거트에 속한 객체를 직접 변경하면 안된다. 애그리거트 루트가 강제하는 규칙을 적용할 수 없어 일관성이 깨진다. 이는 업무 규칙을 무시하고 DB 테이블에 직접 데이터를 수정하는 것과 같은 위험한 행동이고, 그 결과 논리적인 데이터 일관성이 깨지게 된다. 특히, null 체크와 같은 상태 확인 로직도 애그리거트 루트에 구현한다. (관심사 누수 방지, OOP 위반, 도둑놈 코드)

- 실천사항
  - 수정자 메소드를 만들지 않거나, private 접근 범위로 한다. public 접근 범위로 한다면, 메소드 이름도 setXXX로 하지 않고 의미있는 메소드 이름을 부여한다.
  - Value Object는 불변객체로 만든다.

### 애그리거트 루트의 기능 구현

애그리거트 내부의 객체들과 협력하여 기능을 완성한다.

애그리거트 루트 안에서 협력하는 객체는 접근자, 수정자 메소드의 접근 범위를 잘 지정하여 외부에서 접근가능 하지 않도록 해야 한다.
불변객체로 만든다거나, 패키지, protected 접근 법위를 사용한다.

### 트랜잭션 범위

한 트랜잭션에서 한 애그리거트만 수정한다는 것은 애그리거트에서 다른 애그리거트를 변경하지 않는다는 의미임.
그러나, 이는 구현관점에서 반드시 그런것은 아니다.
다만, 애그리거트의 책임이 그 애그리거트 범위를 넘어서 다른 애그리거트에 전파 되지 않게 함을 하기 위해서다.
즉, 애그리거트 간 의존하지 않게 한다는 의미이다.
두개 이상의 애그리거트를 변경해야 한다면, 응용서비스에서 각 애그리거트의 상태를 변경한다.

## 리포지터리와 애그리거트

애그리거트는 개념상 완전한 한 개의 도메인 모델을 표현하므로 객체의 영속성을 처리하는 리포지터리는 애그리거트 단위로 존재

## ID를 이용한 애그리거트 참조

한 객체가 다른 객체를 참조하는 것처럼 애그리거트도 다른 애그리거트를 참조한다. 그런데 뭐가 문제를 야기 시킬까?

- 애그리거트는 경계를 갖는다고 했는데, 이 논리가 깨진다. 또, 참조를 하면 다른 애그리거트 상태를 변경할 가능성이 높아진다.
- 편한 탐색 오용
- 성능 고민
- 확장 어려움

ID를 이용한 참조를 통해서 위 문제가 모두 해결된다.

### ID를 이용한 참조와 조회 성능

ID를 이용한 애그리거트 참조는 지연로딩과 같은 효과를 만드는데, 지연로딩과 관련된 대표적인 문제가 N+1 조회 문제다.
이 문제는 전용 조회쿼리를 만들어서 해결한다.

## 애그리거트 간 집합 연관

1:N 연관관계를 실제 구현하는 경우는 드물고, N:1 연관관계를 이용하도록 하고, 이 또한 ID를 이용한 참조 방식을 사용한다.(또한, 양방향이 아닌 단방향이다.)
M:N 연관관계의 경우, 양방향 연관관계는 드물고, 단방향 M:N 연관관계만 적용하는 경우가 많다.

> 결과적으로, 양방향 관계가 드물다. 개념적으로 양방향이어도, 구현입장에서 보면 대부분 단방향이라는 의미로 이해해 보자.
단방향이 덜 복잡하기도 하다.
연관 관계를 맺은 객체의 life cycle도 고려해 보자. 같은 life cycle 이라면, Value 이다.
다른 life cycle 이면 entity 이고, ID를 이용한 참조를 할 것.
지금까지 나온 내용을 종합해 보면 JPA에서 제공하는 @OneToOne @OneToMany @ManyToOne @ManyToMany 는 거의 이용되지 않는 것 같다. (**애그리거트 내부에서 엔티티 참조만 의미 있음!!!**)
서로 참조하는 객체가 Aggregate 이고, 특히 Aggregate Root 일 수 있기 때문이다.
따라서 대부분 ID를 이용한 참조 방식과 함께, 조회 전용 쿼리를 사용하는 방식을 채택하는것 같다.
4장에서 설명 되겠지만, @OneToOne @OneToMany @ManyToOne @ManyToMany 를 사용하더라도, 대부분 LAZY fetch 방식을 이용한다.

아래 코드는 Category 와 Product M:N 관계를, Product에서 Category로 향하는, 단방향 1:N 관계로 만든 예

```java
class Product {  
  @ElementCollection
  @CollectionTable(name = "product_category",
    joinColumns = @JoinColumn(name = "product_id"))
  private Set<CategoryId> categoryIds;
}
```

## 애그리거트를 팩토리로 사용하기

애그리거트가 갖고 있는 데이터를 이용해서 다른 애그리거트를 생성해야 한다면
애그리거트에 팩토리 메소드 구현을 고려.

> 객체를 생성하고, 변경하고, 삭제하는 것이 프로그래밍의 전부라고 보자. 계층형 아키텍쳐를 이용하여 개발을 하는데, 우리가 흔히 실수하고 구현하는 방법이 두터운 응용서비스를 만드는 것이다. 객체 상태 변경은 그 객체에게 책임을 위임하자. 객체 생성은 애그리거트 팩토리를 고려하여 구현하도록 하자. 그것이 아니라면, 응용 서비스에서 객체는 생성된다.

`응용서비스 구현시 도메인이 규칙이나 로직을 응용에서 구현하고 있는건 아닌지? 항상 의심하고 의심해야 한다.`

# 더 생각해 볼 문제

전용 조회 쿼리를 JPQL or nativeSQL로 작성할 경우, Persistence Context에 객체가 생성되는지 확인할 것!

Theta 조인

Outer 조인
